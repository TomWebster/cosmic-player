---
phase: 01-foundation-audio-playback
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/scripts/audioPlayer.js
  - src/scripts/splashScreen.js
  - src/scripts/main.js
autonomous: false

must_haves:
  truths:
    - "Clicking the splash creates AudioContext and begins playing the first track"
    - "User can skip to next track and hear the correct audio play"
    - "User can skip to previous track and hear the correct audio play"
    - "User can adjust volume with slider and hear the volume change smoothly"
    - "User can mute and unmute audio"
    - "When a track ends, the next track plays automatically"
    - "After the last track ends, playback loops back to the first track"
  artifacts:
    - path: "src/scripts/audioPlayer.js"
      provides: "Audio engine with hybrid HTML5 Audio + Web Audio API architecture"
      exports: ["createAudioPlayer"]
      min_lines: 80
    - path: "src/scripts/splashScreen.js"
      provides: "Splash screen click handler that initializes AudioContext and begins playback"
      exports: ["initSplash"]
      min_lines: 15
    - path: "src/scripts/main.js"
      provides: "Application entry point that wires all modules together"
      min_lines: 20
  key_links:
    - from: "src/scripts/main.js"
      to: "src/scripts/audioPlayer.js"
      via: "import createAudioPlayer"
      pattern: "import.*audioPlayer"
    - from: "src/scripts/main.js"
      to: "src/scripts/splashScreen.js"
      via: "import initSplash"
      pattern: "import.*splashScreen"
    - from: "src/scripts/main.js"
      to: "src/scripts/canvasRenderer.js"
      via: "import initCanvas"
      pattern: "import.*canvasRenderer"
    - from: "src/scripts/splashScreen.js"
      to: "src/scripts/audioPlayer.js"
      via: "calls player.play() inside click handler after AudioContext creation"
      pattern: "audioContext|AudioContext"
    - from: "src/scripts/audioPlayer.js"
      to: "src/data/playlist.json"
      via: "fetch to load playlist"
      pattern: "fetch.*playlist\\.json"
    - from: "src/scripts/audioPlayer.js"
      to: "audio element"
      via: "createMediaElementSource routing through GainNode"
      pattern: "createMediaElementSource"
---

<objective>
Implement the complete audio playback system and wire all modules together into a working application. This plan delivers the core Phase 1 experience: click to enter, hear music, navigate tracks, control volume.

Purpose: This is the heart of Phase 1 -- transforming the static scaffold into a functional immersive audio player. After this plan, all Phase 1 success criteria are met.

Output: Three JavaScript modules (audioPlayer.js, splashScreen.js, main.js) that together deliver working audio playback with playlist management, volume control, and splash-to-playback transition.
</objective>

<execution_context>
@/Users/tomw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-audio-playback/01-RESEARCH.md
@.planning/phases/01-foundation-audio-playback/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement audio player module with hybrid architecture</name>
  <files>src/scripts/audioPlayer.js</files>
  <action>
Create src/scripts/audioPlayer.js as an ES module that exports a `createAudioPlayer` factory function.

**createAudioPlayer(audioElement):**
Takes the HTML audio element as parameter. Returns a player object with methods. Does NOT create AudioContext yet (that happens in the splash click handler).

**Internal state:**
- `playlist` (array, initially empty)
- `currentIndex` (number, starts at 0)
- `audioContext` (null until initialized)
- `gainNode` (null until initialized)
- `source` (MediaElementSourceNode, null until initialized)
- `isMuted` (boolean, false)
- `previousVolume` (number, 0.5)

**player.loadPlaylist():**
- Fetches '/data/playlist.json' using Fetch API
- Checks response.ok, throws on HTTP errors
- Parses JSON and stores tracks array in `playlist`
- Returns the playlist for chaining
- MUST handle errors: log to console, don't silently fail (see Pitfall 6 from research)

**player.initAudio():**
- Creates new AudioContext() -- MUST be called inside user gesture handler
- Creates MediaElementSource from the audio element via audioContext.createMediaElementSource(audioElement)
- Creates GainNode
- Connects chain: source -> gainNode -> audioContext.destination
- Sets up 'ended' event listener on audioElement for auto-advance:
  - On 'ended': increment currentIndex, wrap to 0 if past end (modulo), call loadTrack + play
  - This implements PLAY-02 (auto-advance) and PLAY-03 (loop)
- Stores audioContext, gainNode, source in internal state
- Returns audioContext (caller may need it)

**player.loadTrack(index):**
- Sets currentIndex = index
- Sets audioElement.src = playlist[index].filePath
- Fires track change callbacks with the track object
- Returns the track object for UI updates

**player.play():**
- If audioContext is suspended, calls audioContext.resume()
- Calls audioElement.play() and handles the returned promise
- Catches rejection and logs warning (see Pitfall 8 from research)
- DOES NOT call loadTrack -- caller is responsible for loading first

**player.playTrack(index):**
- Convenience method: calls loadTrack(index) then play()

**player.nextTrack():**
- currentIndex = (currentIndex + 1) % playlist.length
- Calls playTrack(currentIndex)

**player.previousTrack():**
- currentIndex = (currentIndex - 1 + playlist.length) % playlist.length
- Calls playTrack(currentIndex)

**player.setVolume(value):**
- Takes 0-1 float
- Uses gainNode.gain.exponentialRampToValueAtTime(Math.max(0.01, value), audioContext.currentTime + 0.1)
- NEVER set gainNode.gain.value directly -- causes audio pops (see Pitfall 3 from research)
- exponentialRamp cannot reach 0, so clamp minimum to 0.01

**player.toggleMute():**
- If muted: restore previousVolume via setVolume(), set isMuted = false
- If not muted: save current gain value to previousVolume, ramp gain to 0.01 over 100ms, set isMuted = true
- Returns isMuted state for UI updates

**player.getState():**
- Returns { currentIndex, currentTrack: playlist[currentIndex], isMuted, playlist }
- Useful for UI updates

**player.onTrackChange(callback):**
- Registers a callback that fires whenever the track changes (from auto-advance, next, or previous)
- Store callbacks in an array, call all on track change
- This lets the UI update without tight coupling

Export: `export { createAudioPlayer }`

**Critical implementation notes from research:**
- Single AudioContext for entire app lifecycle -- never create new ones per track
- Use HTMLMediaElement (not AudioBufferSourceNode) for streaming long tracks
- Handle audio.play() promise rejection everywhere it's called
- exponentialRampToValueAtTime for all volume changes (never direct .value)
  </action>
  <verify>
The module can be imported without errors:
1. Add a temporary test in browser console after page load: verify `createAudioPlayer` is accessible
2. Verify the file has no syntax errors by loading the page and checking console
3. Code review: confirm exponentialRampToValueAtTime is used (not direct .value), confirm 'ended' event listener exists, confirm modulo wrap logic for next/prev
  </verify>
  <done>
audioPlayer.js exports createAudioPlayer that provides: playlist loading from JSON, AudioContext initialization (for calling inside gesture handler), track loading/playing, next/previous with wrap-around, volume control with smooth ramping, mute/unmute toggle, auto-advance on track end with loop, and a track change callback system.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement splash screen and wire application together</name>
  <files>src/scripts/splashScreen.js, src/scripts/main.js</files>
  <action>
**src/scripts/splashScreen.js:**

Create an ES module that exports `initSplash`.

**initSplash(enterButton, splashElement, onEnter):**
- Takes the enter button element, the splash container element, and an `onEnter` async callback
- Adds a click event listener to enterButton
- On click:
  1. Calls await onEnter() -- this is where AudioContext creation and playback start happen (passed in from main.js)
  2. Adds a CSS class to fade out or hide the splash (e.g., splashElement.classList.add('hidden'))
  3. Removes the event listener (one-time action -- prevent double-clicks creating multiple AudioContexts)
- The splash module does NOT know about audio -- it just orchestrates the enter transition and delegates to the callback. This keeps it decoupled.

Export: `export { initSplash }`

**src/scripts/main.js:**

This is the application entry point that imports and wires all modules together.

```
import { initCanvas } from './canvasRenderer.js';
import { createAudioPlayer } from './audioPlayer.js';
import { initSplash } from './splashScreen.js';
```

**On DOMContentLoaded (or at module execution since type="module" defers):**

1. Initialize canvas: `initCanvas()`

2. Get DOM elements:
   - audioElement = document.getElementById('audio-player')
   - enterButton = document.getElementById('enter-button')
   - splashElement = document.getElementById('splash')
   - prevBtn = document.getElementById('prev-btn')
   - nextBtn = document.getElementById('next-btn')
   - volumeSlider = document.getElementById('volume-slider')
   - muteBtn = document.getElementById('mute-btn')
   - controlsContainer = document.getElementById('controls')

3. Create audio player: `const player = createAudioPlayer(audioElement)`

4. Load playlist eagerly: `await player.loadPlaylist()` (or .then() -- load playlist before user clicks so playback starts instantly on enter)

5. Initialize splash with onEnter callback:
   ```
   initSplash(enterButton, splashElement, async () => {
     player.initAudio();              // Creates AudioContext inside gesture
     player.loadTrack(0);             // Load first track
     await player.play();             // Start playback
     controlsContainer.classList.remove('hidden');  // Show controls
   });
   ```

6. Wire control buttons:
   - prevBtn click -> player.previousTrack()
   - nextBtn click -> player.nextTrack()
   - volumeSlider 'input' event -> player.setVolume(parseFloat(e.target.value))
   - muteBtn click -> player.toggleMute(), update button text to show muted/unmuted state, update slider position to 0 when muted

7. Wire track change callback:
   ```
   player.onTrackChange((track) => {
     // For Phase 1, just log track changes
     // Phase 4 will add track info display
     console.log(`Now playing: ${track.title} - ${track.artist}`);
   });
   ```

**Critical: The AudioContext MUST be created inside the splash click handler's call stack.** The onEnter callback runs synchronously within the click event, so player.initAudio() inside it satisfies the browser autoplay policy. If you await something before initAudio(), the user gesture context may be lost.

**Critical: Load playlist BEFORE the click handler fires.** Fetching JSON inside the click handler adds latency between click and audio start. Pre-load the playlist on page load so clicking triggers instant playback.

Export: Nothing (entry point)
  </action>
  <verify>
Serve the site with `python3 -m http.server 8000` from the src/ directory, then:
1. Open http://localhost:8000 in browser
2. Verify splash screen appears
3. Click "Enter" -- verify splash disappears, controls appear
4. Check browser console for "Now playing: [track]" log (audio won't actually play without real audio files, but the flow should execute without errors)
5. Click next/prev buttons -- verify console logs track changes with correct wrap-around
6. Move volume slider -- verify no errors (volume change won't be audible without audio files)
7. Click mute button -- verify no errors, button text updates
8. Check console for any unhandled promise rejections or errors
  </verify>
  <done>
Splash screen click initializes AudioContext and begins playback flow. Controls are revealed after entry. Next/previous buttons navigate playlist with wrap-around. Volume slider controls gain smoothly. Mute button toggles audio. Track changes fire callbacks. All wiring is complete -- the application works end-to-end (audio output depends on valid audio files being present at playlist paths).
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete audio playback flow</name>
  <files>src/scripts/audioPlayer.js, src/scripts/splashScreen.js, src/scripts/main.js</files>
  <action>
Human verification checkpoint. Claude has built the complete Phase 1 audio player: click-to-enter splash that initializes Web Audio API, plays music from a playlist loaded from JSON, with next/previous track navigation, volume slider, mute toggle, auto-advance on track end, and playlist looping.

To test with real audio, you need audio files. Either:
(a) Copy a few MP3 files to src/audio/ and update src/data/playlist.json with correct filePaths, OR
(b) If appleMusicTools has already generated a playlist, copy that JSON to src/data/playlist.json

Then test:
1. Start server: `cd src && python3 -m http.server 8000`
2. Open http://localhost:8000
3. Verify: Splash screen is visible with "Enter" button on black background
4. Click "Enter" -- splash disappears, audio begins, controls appear at bottom
5. Click "Next" -- next track starts playing
6. Click "Prev" -- previous track starts playing
7. Move volume slider -- volume changes smoothly (no clicks/pops)
8. Click "Mute" -- audio goes silent, button indicates muted state
9. Click "Mute" again -- audio restores to previous volume
10. Let a track play to completion -- next track auto-advances
11. Navigate to last track and let it end -- playback loops to track 1
  </action>
  <verify>
All 11 test steps pass. No console errors. Audio plays continuously after entry. Controls are responsive and functional.
  </verify>
  <done>
User has confirmed the complete Phase 1 flow works: splash entry, audio playback, track navigation, volume control, mute toggle, auto-advance, and playlist looping. Type "approved" or describe issues.
  </done>
</task>

</tasks>

<verification>
Phase 1 success criteria from ROADMAP.md:
1. Visitor sees a click-to-enter splash screen on page load -- verified by splash overlay visibility
2. Clicking the splash creates AudioContext and begins playing the first track -- verified by audio output after click
3. User can skip to next/previous tracks and hear the correct audio play -- verified by button clicks changing tracks
4. User can adjust volume with slider and mute/unmute audio -- verified by volume changes and mute toggle
5. Playlist auto-advances through tracks and loops back to start after the last track -- verified by letting tracks end

Requirements coverage:
- ENTR-01: Splash screen on load (Plan 01 + Plan 02)
- ENTR-02: Click triggers AudioContext + playback (Plan 02 Task 2)
- ENTR-03: Canvas revealed after entry (Plan 01 Task 2 + Plan 02 Task 2 -- canvas is behind splash, revealed when splash hides)
- PLAY-01: Loads playlist of local audio files (Plan 02 Task 1 -- loadPlaylist)
- PLAY-02: Auto-advances to next track (Plan 02 Task 1 -- 'ended' event)
- PLAY-03: Loops back to first track (Plan 02 Task 1 -- modulo wrap in 'ended' handler)
- PLAY-04: Skip to next (Plan 02 Task 1 -- nextTrack)
- PLAY-05: Skip to previous (Plan 02 Task 1 -- previousTrack)
- PLAY-06: Volume slider (Plan 02 Task 2 -- slider wiring)
- PLAY-07: Mute/unmute (Plan 02 Task 1 -- toggleMute)
- DATA-01: Playlist from JSON (Plan 01 Task 1 + Plan 02 Task 1)
- DATA-02: JSON from appleMusicTools pipeline (external -- playlist.json format is compatible)
</verification>

<success_criteria>
- Clicking splash initializes AudioContext (not suspended) and plays first track
- Next/previous buttons change tracks with correct wrap-around at boundaries
- Volume slider smoothly adjusts volume without audio clicks or pops
- Mute toggle silences and restores audio
- Track auto-advances when current track ends
- Playlist loops from last track back to first
- No unhandled promise rejections in console
- No "AudioContext was not allowed to start" warnings
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-audio-playback/01-02-SUMMARY.md`
</output>
